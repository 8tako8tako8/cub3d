# cub3D（lodev）
lodev: https://lodev.org/cgtutor/raycasting.html

・ 壁を描画するための基本的な考え方

プレイヤーの位置からrayを飛ばし、各マスの境界ごとに壁のマス(1)であるかを判別する。壁であるならば、プレイヤーとの距離を計算し、その距離が描画する壁の高さとなる。

![](https://i.imgur.com/4oZ2Bw0.gif)　![](https://i.imgur.com/j9cImhb.gif)

$プレイヤーの位置ベクトルを\vec{pos}、
方向ベクトルを\vec{dir}$
$カメラ平面ベクトルを\vec{plane}とする。$

カメラ平面ベクトルは方向ベクトルに垂直なベクトルである。
下図のように、方向ベクトルに垂直な<span style="color: blue; ">青線</span>をひくと、黒点はプレイヤーの位置ベクトル＋方向ベクトルで表され、<span style="color: blue; ">青線</span>はプレイヤーの位置ベクトル＋方向ベクトル±カメラ平面ベクトルで表される。

![](https://i.imgur.com/DwHgi5s.gif)

また、外側２本の間の角度はFOVと呼ばれ、方向ベクトルとカメラ平面ベクトルの比率によって決まる。

プレイヤーが回転した時に、それぞれのベクトルも回転させる必要があり、回転行列をかける。

\begin{pmatrix}
\cos\theta & -\sin\theta \\
\sin\theta & \cos\theta
\end{pmatrix}

今回は、下図のように設定する。

$FOV = 2\tan^{-1}(\frac{0.66}{1.0}) = 66°$<img src="https://i.imgur.com/F1JOj0W.png" width="300">

Untextured Raycaster
```
for(int x = 0; x < w; x++)
{
    //calculate ray position and direction
    double cameraX = 2 * x / double(w) - 1; //x-coordinate in camera space
    double rayDirX = dirX + planeX * cameraX;
    double rayDirY = dirY + planeY * cameraX;
```

cameraXはカメラ空間のx座標を表す。
rayDirはrayの方向ベクトルを表す。
$cameraX = \frac{2x - WIDTH}{WIDTH} = \frac{2x}{WIDTH} - 1$<img src="https://i.imgur.com/rVTMnFQ.png" width="200">

```
//which box of the map we're in
int mapX = int(posX);
int mapY = int(posY);

//length of ray from current position to next x or y-side
double sideDistX;
double sideDistY;

//length of ray from one x or y-side to next x or y-side
double deltaDistX = std::abs(1 / rayDirX);
double deltaDistY = std::abs(1 / rayDirY);
double perpWallDist;

//what direction to step in x or y-direction (either +1 or -1)
int stepX;
 int stepY;

int hit = 0; //was there a wall hit?
int side; //was a NS or a EW wall hit?
```

mapX,mapYはrayの位置を表す(int型)

sideDistX:「出発点から最初のx面に出会う点」までの距離
sideDistY:「出発点から最初のy面に出会う点」までの距離
deltaDistX:最初のx面から次のx面の距離(xは１だけ移動)
deltaDistY:最初のy面から次のy面の距離(yは１だけ移動)

deltaDistを簡略化すると以下のようになるらしい。
$deltaDistX = |\frac{1}{rayDirX}|$
$deltaDistY = |\frac{1}{rayDirY}|$

 ![](https://i.imgur.com/eSb72T0.gif)

・DDAアルゴリズムを始める前にstepX, stepYの初期値を求める。
 ○rayDirXが正の時、stepX = +1, 負の時、stepX = -1
 ○rayDirXが0の時、stepXは使わない。
 ○stepYも同様
```
//calculate step and initial sideDist
if (rayDirX < 0)
{
    stepX = -1;
    sideDistX = (posX - mapX) * deltaDistX;
}
else
{
    stepX = 1;
    sideDistX = (mapX + 1.0 - posX) * deltaDistX;
}
if (rayDirY < 0)
{
    stepY = -1;
    sideDistY = (posY - mapY) * deltaDistY;
}
else
{
    stepY = 1;
    sideDistY = (mapY + 1.0 - posY) * deltaDistY;
}
```
<br>

(１)rayDirX>0の時
$sideDistX:deltaDistX=(mapX+1)-posX:1$
$\Leftrightarrow sideDistX=(mapX+1-posX)\times deltaDistX$
　　　　<img src="https://i.imgur.com/HsVhju0.png" width="200">

(2)rayDirX<0の時
$sideDistX:deltaDistX=posX-mapX:1$
$\Leftrightarrow sideDistX=(posX-mapX)\times deltaDistX$

　<img src="https://i.imgur.com/eoj4YgK.png" width="200">

・DDAアルゴリズム

```
//perform DDA
while (hit == 0)
{
    //jump to next map square, OR in x-direction, OR in y-direction
    if (sideDistX < sideDistY)
    {
        sideDistX += deltaDistX;
        mapX += stepX;
        side = 0;
    }
    else
    {
        sideDistY += deltaDistY;
        mapY += stepY;
        side = 1;
    }
    //Check if ray has hit a wall
    if (worldMap[mapX][mapY] > 0) hit = 1;
} 
```
<br>

 ○壁にぶつかるまで毎回１マスずつrayを移動させる(インクリメントする)
 
<img src="https://i.imgur.com/Ub603ss.png" width="400">

<br>
<br>

①sideDistX < sideDistY であり、
sideDistX += deltaDistX
mapX += stepX
side = 0

<img src="https://i.imgur.com/faY52AX.png" width="400">

<br>
<br>

②sideDistX > sideDistY であり、
sideDistY += deltaDistY
mapY += stepY
side = 1

①,②の大小比較を繰り返しつつ、 worldmap[mapX][mapY]>0であるかを確認する。

・rayの開始点から壁までの移動距離perpWallDistを計算する。
(魚眼レンズにならないようにカメラ平面からの距離を求める）

```
//Calculate distance projected on camera direction (Euclidean distance will give fisheye effect!)
if (side == 0) perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;
else           perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;
```
<br>

壁の見え方

![](https://i.imgur.com/1N6qUTb.png)<img src="https://i.imgur.com/P6YHTw2.png" width="250">

<img src="https://i.imgur.com/9UiVK9i.png" width="500">

<br>
<br>

perpWallDistの求め方

![](https://i.imgur.com/K15NnE7.png)

<br>

計算過程

<img src="https://i.imgur.com/6NiUymC.png)
" width="600">

したがって、perpWallDist:dir = HP : DP = HB : DC

$HB = mapY - posY + \frac{1 - stepY}{2}$

rayDirY > 0の時、stepY = 1 により $HB = mapY - posY + 0$

rayDirY < 0の時、stepY = -1 により $HB = mapY - posY + 1$

$perpWallDist = \frac{HB\times dir}{DC} = \frac{mapY - posY + (1 - stepY)/2}{rayDirY}$

<br>

・画面に描画する壁の高さ
```
//Calculate height of line to draw on screen
int lineHeight = (int)(h / perpWallDist);

//calculate lowest and highest pixel to fill in current stripe
int drawStart = -lineHeight / 2 + h / 2;
if(drawStart < 0)drawStart = 0;
int drawEnd = lineHeight / 2 + h / 2;
if(drawEnd >= h)drawEnd = h - 1;
```

$lineheight = (int)(HEIGHT / perpWallDist)$
perpWallDistにより描画する高さが変化する。

<img src="https://i.imgur.com/9QKWmoF.png)
" width="600">

<br>
<br>

・入力キーに対応した移動
回転は回転行列をかけるだけ。

```
readKeys();
//move forward if no wall in front of you
if (keyDown(SDLK_UP))
{
    if(worldMap[int(posX + dirX * moveSpeed)][int(posY)] == false) posX += dirX * moveSpeed;
    if(worldMap[int(posX)][int(posY + dirY * moveSpeed)] == false) posY += dirY * moveSpeed;
}
//move backwards if no wall behind you
if (keyDown(SDLK_DOWN))
{
    if(worldMap[int(posX - dirX * moveSpeed)][int(posY)] == false) posX -= dirX * moveSpeed;
    if(worldMap[int(posX)][int(posY - dirY * moveSpeed)] == false) posY -= dirY * moveSpeed;
}
//rotate to the right
if (keyDown(SDLK_RIGHT))
{
    //both camera direction and camera plane must be rotated
    double oldDirX = dirX;
    dirX = dirX * cos(-rotSpeed) - dirY * sin(-rotSpeed);
    dirY = oldDirX * sin(-rotSpeed) + dirY * cos(-rotSpeed);
    double oldPlaneX = planeX;
    planeX = planeX * cos(-rotSpeed) - planeY * sin(-rotSpeed);
    planeY = oldPlaneX * sin(-rotSpeed) + planeY * cos(-rotSpeed);
}
//rotate to the left
if (keyDown(SDLK_LEFT))
{
    //both camera direction and camera plane must be rotated
    double oldDirX = dirX;
    dirX = dirX * cos(rotSpeed) - dirY * sin(rotSpeed);
    dirY = oldDirX * sin(rotSpeed) + dirY * cos(rotSpeed);
    double oldPlaneX = planeX;
    planeX = planeX * cos(rotSpeed) - planeY * sin(rotSpeed);
    planeY = oldPlaneX * sin(rotSpeed) + planeY * cos(rotSpeed);
}
```

<br>


〜Textured Raycaster〜
・rayが壁のy面にぶつかった場合(side=1)に自然な照明にするために暗くする表現
R,G,Bを２で割ると色が暗くなる。１０進数を１０で割ると最後の桁が削除される。つまり、２進数で割ることは最後のビットを削除することと同じである。
if (side == 1) color = (color >> 1) & 8355711;
これは、>>1で右にビットシフトすることで最後のビットを削除する。実際には32ビットのうち最初の8ビットはしようされず、次の24ビットが色を表すので、>>1により、8ビット目が9ビット目になり、色の情報が崩れる。したがって、全てのバイトの最初のビットをゼロに設定する必要があり、
01111111 01111111 01111111 (10進数で8355711)
をAND演算する。これにより暗い色になる。

```
// How much to increase the texture coordinate per screen pixel
double step = 1.0 * texHeight / lineHeight;
// Starting texture coordinate
double texPos = (drawStart - h / 2 + lineHeight / 2) * step;
for(int y = drawStart; y<drawEnd; y++)
{
    // Cast the texture coordinate to integer, and mask with (texHeight - 1) in case of overflow
    int texY = (int)texPos & (texHeight - 1);
    texPos += step;
    Uint32 color = texture[texNum][texHeight * texY + texX];
    //make color darker for y-sides: R, G and B byte each divided through two with a "shift" and an "and"
    if(side == 1) color = (color >> 1) & 8355711;
    buffer[y][x] = color;
}
```

<br>

・spriteの描画

①各垂直距離をzBufferに保存
②各スプライトからプレイヤーまでの距離を計算
③②の距離を遠い順にする。
④スプライトをカメラ平面に投影する。スプライト位置からプレイヤー位置を引き、その結果にカメラ平面の逆行列をかける。
⑤垂直距離を使用して、画面上のスプライトサイズを計算する
⑥スプライトを垂直方向のスプライトごとに描画する。距離が現在のストライプの壁のzBufferよりも遠い時は描画しない。
⑦縦縞をピクセルごとに描画する

スプライトは並び替えているので、遠くにあるものから描画される。
プレイヤーから見た各点は方向ベクトルとカメラ平面ベクトルで表されることから、カメラ行列で以下で表される。

\begin{pmatrix}
planeX & dirX \\
planeY & dirY
\end{pmatrix}

これの逆行列をかけることで、スプライトをカメラ平面に投影することができる。（これをしなければ画面上の同じ場所にスプライトがあり続けるはず）

①各垂直距離をzBufferに保存
```
//SET THE ZBUFFER FOR THE SPRITE CASTING
ZBuffer[x] = perpWallDist; //perpendicular distance is used
```

②各スプライトからプレイヤーまでの距離を計算
```
spriteDistance[i] = ((posX - sprite[i].x) * (posX - sprite[i].x) + (posY - sprite[i].y) * (posY - sprite[i].y)); //sqrt not taken, unneeded
```

③②の距離を遠い順にする。
```
sortSprites(spriteOrder, spriteDistance, numSprites);
```

④スプライトをカメラ平面に投影する。スプライト位置からプレイヤー位置を引き、その結果にカメラ平面の逆行列をかける。(スプライトの位置をカメラの相対位置に投影)
```
//after sorting the sprites, do the projection and draw them
for(int i = 0; i < numSprites; i++)
{
    //translate sprite position to relative to camera
    double spriteX = sprite[spriteOrder[i]].x - posX;
    double spriteY = sprite[spriteOrder[i]].y - posY;

    //transform sprite with the inverse camera matrix
    // [ planeX   dirX ] -1                                       [ dirY      -dirX ]
    // [               ]       =  1/(planeX*dirY-dirX*planeY) *   [                 ]
    // [ planeY   dirY ]                                      [ -planeY  planeX ]

    double invDet = 1.0 / (planeX * dirY - dirX * planeY); //required for correct matrix multiplication

    double transformX = invDet * (dirY * spriteX - dirX * spriteY);
    double transformY = invDet * (-planeY * spriteX + planeX * spriteY); //this is actually the depth inside the screen, that what Z is in 3D
```


⑤垂直距離を使用して、画面上のスプライトサイズを計算する

```
int spriteScreenX = int((w / 2) * (1 + transformX / transformY));
```
画面のスプライトの高さを計算（実際の距離の代わりにtransformYを使用し魚眼レンズを防止）

```
//calculate height of the sprite on screen
int spriteHeight = abs(int(h / (transformY))); //using 'transformY' instead of the real distance prevents fisheye
```

現在のストライプを埋めるために最低ピクセルと最高ピクセルを計算

```
//calculate lowest and highest pixel to fill in current stripe
int drawStartY = -spriteHeight / 2 + h / 2;
if(drawStartY < 0) drawStartY = 0;
int drawEndY = spriteHeight / 2 + h / 2;
if(drawEndY >= h) drawEndY = h - 1;
```
スプライトの幅を計算

```
//calculate width of the sprite
int spriteWidth = abs( int (h / (transformY)));
int drawStartX = -spriteWidth / 2 + spriteScreenX;
if(drawStartX < 0) drawStartX = 0;
int drawEndX = spriteWidth / 2 + spriteScreenX;
if(drawEndX >= w) drawEndX = w - 1;
```

⑥スプライトを垂直方向のスプライトごとに描画する。距離が現在のストライプの壁のzBufferよりも遠い時は描画しない。
⑦縦縞をピクセルごとに描画する

```
//loop through every vertical stripe of the sprite on screen
for(int stripe = drawStartX; stripe < drawEndX; stripe++)
{
    int texX = int(256 * (stripe - (-spriteWidth / 2 + spriteScreenX)) * texWidth / spriteWidth) / 256;
    //the conditions in the if are:
    //1) it's in front of camera plane so you don't see things behind you
    //2) it's on the screen (left)
    //3) it's on the screen (right)
    //4) ZBuffer, with perpendicular distance
    if(transformY > 0 && stripe > 0 && stripe < w && transformY < ZBuffer[stripe])
    for(int y = drawStartY; y < drawEndY; y++) //for every pixel of the current stripe
    {
         int d = (y) * 256 - h * 128 + spriteHeight * 128; //256 and 128 factors to avoid floats
         int texY = ((d * texHeight) / spriteHeight) / 256;
         Uint32 color = texture[sprite[spriteOrder[i]].texture][texWidth * texY + texX]; //get current color from the texture
         if((color & 0x00FFFFFF) != 0) buffer[y][stripe] = color; //paint pixel if it isn't black, black is the invisible color
}
```

